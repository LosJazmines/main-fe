import{a}from"./chunk-Q7WZ5A67.js";import{a as c}from"./chunk-RAAZGNEA.js";import{a as f}from"./chunk-YVLEHWOY.js";import{l as d}from"./chunk-EWYMWOI3.js";import{a as r}from"./chunk-HE4HGFF6.js";import{a as i,b as s,ka as l,l as o,pa as h}from"./chunk-W7KOHNRA.js";var C=(()=>{class n{constructor(t,e){this.store=t,this.authService=e,this.ordersSocket=null,this.notificationsSocket=null,this.contactSocket=null,this.isConnected=!1,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectInterval=1e3,this.storeSubscription=null,this.isConnecting=!1,this.connectionStatus$=new o(!1),this.newOrders$=new o(null),this.orderUpdates$=new o(null),this.orderStatusChanges$=new o(null),this.notifications$=new o(null),this.adminNotifications$=new o(null),console.log("WebSocketService initialized"),this.setupStoreSubscription()}setupStoreSubscription(){console.log("Setting up store subscription"),this.storeSubscription=this.store.select(c).subscribe(t=>{console.log("user",t),console.log("User state changed:",t?"authenticated":"not authenticated");let e=t?.token||this.authService.getToken();e?this.connect(e):this.disconnect()})}connect(t){if(this.isConnected||this.isConnecting){console.log("Already connected or connecting, skipping connection attempt");return}this.isConnecting=!0,console.log("Attempting to connect to WebSocket servers");try{this.disconnect();let e={transports:["websocket","polling"],auth:{token:`Bearer ${t}`},path:"/socket.io",reconnection:!0,reconnectionAttempts:5,reconnectionDelay:1e3,timeout:2e4,forceNew:!0};this.ordersSocket=a(`${r.wsUrl}`,s(i({},e),{path:"/socket.io/orders"})),this.notificationsSocket=a(`${r.wsUrl}`,s(i({},e),{path:"/socket.io/notifications"})),this.contactSocket=a(`${r.wsUrl}`,s(i({},e),{path:"/socket.io/contact"})),this.setupSocketListeners()}catch(e){console.error("Error creating WebSocket connections:",e),this.isConnecting=!1,this.handleConnectionError()}}setupSocketListeners(){this.ordersSocket&&(this.ordersSocket.on("connect",()=>{console.log("Orders socket connected:",this.ordersSocket?.id),this.updateConnectionStatus()}),this.ordersSocket.on("disconnect",t=>{console.log("Orders socket disconnected:",t),this.updateConnectionStatus(),t!=="io client disconnect"&&this.handleDisconnect()}),this.ordersSocket.on("connect_error",t=>{console.error("Orders socket connection error:",t),this.handleConnectionError()}),this.ordersSocket.on("newOrder",t=>{console.log("New order received:",t),t&&this.newOrders$.next(t)}),this.ordersSocket.on("orderUpdate",t=>{console.log("Order update received:",t),t&&this.orderUpdates$.next(t)}),this.ordersSocket.on("orderStatusChange",t=>{console.log("Order status change received:",t),t&&this.orderStatusChanges$.next(t)})),this.notificationsSocket&&(this.notificationsSocket.on("connect",()=>{console.log("Notifications socket connected:",this.notificationsSocket?.id),this.updateConnectionStatus();let t=this.authService.getCurrentUser()?.id;t&&(console.log("Joining notifications room for user:",t),this.notificationsSocket.emit("joinNotificationsRoom",t));let e=this.authService.getCurrentUser()?.role;console.log("Current user role:",e),e==="admin"?(console.log("Joining admin notifications room"),this.notificationsSocket.emit("joinAdminRoom"),this.notificationsSocket.on("adminRoomJoined",()=>{console.log("Successfully joined admin room")})):console.log("User is not admin, skipping admin room")}),this.notificationsSocket.on("disconnect",t=>{console.log("Notifications socket disconnected:",t),this.updateConnectionStatus()}),this.notificationsSocket.on("notification",t=>{console.log("New notification received (notification event):",t),this.notifications$.next(t)}),this.notificationsSocket.on("newNotification",t=>{console.log("New notification received (newNotification event):",t),this.notifications$.next(t)}),this.notificationsSocket.on("notificationRead",t=>{console.log("Notification marked as read:",t)}),this.notificationsSocket.on("newAdminNotification",t=>{console.log("New admin notification received:",t),t?(console.log("Admin notification details:",{type:t.type,message:t.message,timestamp:t.timestamp}),this.adminNotifications$.next(t)):console.warn("Received empty admin notification")}),this.notificationsSocket.on("error",t=>{console.error("Notifications socket error:",t)})),this.contactSocket&&(this.contactSocket.on("connect",()=>{console.log("Contact socket connected:",this.contactSocket?.id),this.updateConnectionStatus()}),this.contactSocket.on("disconnect",t=>{console.log("Contact socket disconnected:",t),this.updateConnectionStatus()}))}updateConnectionStatus(){let t=this.ordersSocket?.connected||!1||this.notificationsSocket?.connected||!1||this.contactSocket?.connected||!1;this.isConnected=t,this.isConnecting=!1,this.connectionStatus$.next(t),t&&(console.log("WebSocket connection established successfully"),this.reconnectAttempts=0)}handleDisconnect(){if(this.reconnectAttempts<this.maxReconnectAttempts&&!this.isConnecting){this.reconnectAttempts++;let t=this.reconnectInterval*Math.min(this.reconnectAttempts,3);console.log(`Scheduled reconnection in ${t}ms (${this.reconnectAttempts}/${this.maxReconnectAttempts})`),setTimeout(()=>{!this.isConnected&&!this.isConnecting&&this.store.select(c).subscribe(e=>{e?.token&&this.connect(e.token)}).unsubscribe()},t)}else this.reconnectAttempts>=this.maxReconnectAttempts&&(console.log("Max reconnection attempts reached, stopping reconnection attempts"),this.reconnectAttempts=0)}handleConnectionError(){if(this.reconnectAttempts<this.maxReconnectAttempts&&!this.isConnecting){this.reconnectAttempts++;let t=this.reconnectInterval*Math.min(this.reconnectAttempts,3);console.log(`Scheduled reconnection after error in ${t}ms (${this.reconnectAttempts}/${this.maxReconnectAttempts})`),setTimeout(()=>{!this.isConnected&&!this.isConnecting&&this.store.select(c).subscribe(e=>{e?.token&&this.connect(e.token)}).unsubscribe()},t)}else this.reconnectAttempts>=this.maxReconnectAttempts&&(console.log("Max reconnection attempts reached after error, stopping reconnection attempts"),this.reconnectAttempts=0)}disconnect(){this.ordersSocket&&(this.ordersSocket.disconnect(),this.ordersSocket=null),this.notificationsSocket&&(this.notificationsSocket.disconnect(),this.notificationsSocket=null),this.contactSocket&&(this.contactSocket.disconnect(),this.contactSocket=null),this.isConnected=!1,this.isConnecting=!1,this.connectionStatus$.next(!1)}ngOnDestroy(){console.log("WebSocketService being destroyed"),this.disconnect(),this.storeSubscription&&this.storeSubscription.unsubscribe()}getConnectionStatus(){return this.connectionStatus$.asObservable()}getNewOrders(){return this.newOrders$.asObservable()}getOrderUpdates(){return this.orderUpdates$.asObservable()}getOrderStatusChanges(){return this.orderStatusChanges$.asObservable()}getNotifications(){return this.notifications$.asObservable()}getAdminNotifications(){return this.adminNotifications$.asObservable()}markNotificationAsRead(t){if(this.notificationsSocket?.connected){let e=this.authService.getCurrentUser()?.id;e&&this.notificationsSocket.emit("notificationRead",{notificationId:t,userId:e})}}static{this.\u0275fac=function(e){return new(e||n)(h(d),h(f))}}static{this.\u0275prov=l({token:n,factory:n.\u0275fac,providedIn:"root"})}}return n})();export{C as a};
